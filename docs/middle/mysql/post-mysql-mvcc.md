# 前言
本文通过ACID事务和数据库锁的实现机制，引申出mvcc存在的意义和本身解决了哪些问题。
# ACID事务
- 原子性(atomicity)
  - 原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。
- 一致性(consistency)
  - 一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。
- 隔离性(isolation)
  - 多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。
  - 读未提交(read uncommitted)
    - 是事务隔离级别中最低的一种，可以读到未提交的数据，可能引起脏读。
  - 读已提交(read committed)实际使用中并不会出现不可重复读，具体原因参考mvcc机制
    - 只能读取到其他事务已提交的数据，可能会出现不可重复读。比如事务A和事务B同时进行操作， 此时事务A操作A数据，事务B读取A数据两次， 第一次读时A事务未提交，第二次读时A数据提交了，B事务读取两次得到的结果不一致。
  - 可重复读(repeatable read)实际使用中并不会出现幻读，具体原因参考mvcc机制
    - mysql的默认隔离级别，该级别可以保证同一个事务读出的数据都是相同的。但可能产生幻读
    - 例如：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
  - 串行化(serializable)
    - 串行化，绝对的线程安全，多个会话需要排队等待。会对性能造成严重的影响。如果并发事务较多可能引起lock wait timeout。
- 持久性(durability)
  -  持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

# 锁机制
并发更新和写的时候需要有锁机制来保证数据正确。锁又会直接影响到数据库的性能。
## 锁的种类
### 乐观锁
用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。
例如：
```
update TABLE

set value=2,version=version+1

where id=#{id} and version=#{version}
```
### 悲观锁
与乐观锁相对应的就是悲观锁了。悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。
- 共享锁(读锁 read lock)
    - 共享锁又称读锁 (read lock)，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。
使用方式
```
在查询语句后面增加 LOCK IN SHARE MODE ，Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。 其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。

加上共享锁后，对于update，insert，delete语句会自动加排它锁。



打开第一个查询窗口

begin;/begin work;/start transaction; (三者选一就可以)

#(lock in share mode 共享锁)

SELECT * from TABLE where id = 1 lock in share mode;

然后在另一个查询窗口中，对id为1的数据进行更新

update TABLE set name="www.souyunku.com" where id =1;

此时，操作界面进入了卡顿状态，过了很久超时，提示错误信息

如果在超时前，第一个窗口执行commit，此更新语句就会成功。



反过来操作也一样。
```
- 排他锁(写锁 write lock)
    - 若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁，其他进程可以读取,不能进行写操作，需等待其释放。 排它锁是悲观锁的一种实现
使用方式
```
select status from TABLE where id=1 for update;

要使用排他锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。

我们可以使用命令设置MySQL为非autocommit模式：

set autocommit=0;

# 设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：

# 1. 开始事务

begin;/begin work;/start transaction; (三者选一就可以)

# 2. 查询表信息（for update加锁）

select status from TABLE where id=1 for update;

# 3. 插入一条数据

insert into TABLE (id,value) values (2,2);

# 4. 修改数据为

update TABLE set value=2 where id=1;

# 5. 提交事务

commit;/commit work


```
## 锁的等级
### 表级锁
开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高 ，并发度最低
加锁方式：
- 自动加锁： 动加锁。查询操作（SELECT），会自动给涉及的所有表加读锁，更新操作（UPDATE、DELETE、INSERT），会自动给涉及的表加写锁
- 手动加锁
```
共享读锁：lock table tableName read;

独占写锁：lock table tableName write;

批量解锁：unlock tables;
```
适用场景：
- 全表更新：事务需要更新大部分或全部数据，且表又比较大。若使用行锁，会导致事务执行效率低，从而可能造成其他事务长时间锁等待和更多的锁冲突
- 多表查询：事务涉及多个表，比较复杂的关联查询，很可能引起死锁，造成大量事务回滚。这种情况若能一次性锁定事务涉及的表，从而可以避免死锁、减少数据库因事务回滚带来的开销。
### 页面锁
开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
### 行级锁
多个事务操作同一行数据时，后来的事务处于阻塞等待状态。这样可以避免了脏读等数据一致性的问题。后来的事务可以操作其他行数据，解决了表锁高并发性能低的问题。
加锁方式：
- 自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁；
- 手动加锁：
```
即 sql语句+ for update
SELECT UserID,Password,Age FROM AccountsDB.Accounts_InFo   WHERE Accounts = 'hello2' FOR UPDATE; 
```
锁的自动升级：
- 什么场景会升级为表锁：当执行批量修改数据脚本的时候，行锁升级为表锁。其他对订单的操作都处于等待中。
- 升级表锁的原因：InnoDB只有在通过索引条件检索数据时使用行级锁，否则使用表锁！ 而模拟操作正是通过id去作为检索条件，而id又是MySQL自动创建的唯一索引，所以才忽略了行锁变表锁的情况
- 自动升级表锁的意义： 这是因为MySQL有自己的执行计划。 当你需要更新一张较大表的大部分甚至全表的数据时。而你又傻乎乎地用索引作为检索条件。一不小心开启了行锁(没毛病啊！保证数据的一致性！)。可MySQL却认为大量对一张表使用行锁，会导致事务执行效率低，从而可能造成其他事务长时间锁等待和更多的锁冲突问题，性能严重下降。所以MySQL会将行锁升级为表锁，即实际上并没有使用索引。既然整张表的大部分数据都要更新数据，在一行一行地加锁效率则更低。其实我们可以通过explain命令查看MySQL的执行计划，你会发现key为null。表明MySQL实际上并没有使用索引，行锁升级为表锁也和上面的结论一致。
- 行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。
GAP间隙锁：
- 一方面是为了防止幻读，以满足相关隔离级别的要求。另外一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对锁机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况。InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！
- 可能产生的问题：在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。若执行的条件是范围过大，则InnoDB会将整个范围内所有的索引键值全部锁定，很容易对性能造成影响。
- 优化办法： 在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。
行锁优化：
- 分析行锁定：
```
通过检查InnoDB_row_lock 状态变量分析系统上中行锁的争夺情况
innodb_row_lock_current_waits: 当前正在等待锁定的数量
innodb_row_lock_time: 从系统启动到现在锁定总时间长度；非常重要的参数，
innodb_row_lock_time_avg: 每次等待所花平均时间；非常重要的参数，
innodb_row_lock_time_max: 从系统启动到现在等待最常的一次所花的时间；
innodb_row_lock_waits: 系统启动后到现在总共等待的次数；非常重要的参数。直接决定优化的方向和策略。
```
- 优化策略：
    - 尽可能让所有数据检索都通过索引来完成，避免无索引行或索引失效导致行锁升级为表锁。
    - 尽可能避免间隙锁带来的性能下降，减少或使用合理的检索范围。
    - 尽可能减少事务的粒度，比如控制事务大小，而从减少锁定资源量和时间长度，从而减少锁的竞争等，提供性能。
    - 尽可能低级别事务隔离，隔离级别越高，并发的处理能力越低。
### 表锁与行锁的选择
- InnoDB 支持表锁和行锁，使用索引作为检索条件修改数据时采用行锁，否则采用表锁。
- InnoDB 自动给修改操作加锁，给查询操作不自动加锁
- 行锁可能因为未使用索引而升级为表锁，所以除了检查索引是否创建的同时，也需要通过explain执行计划查询索引是否被实际使用。
= 行锁相对于表锁来说，优势在于高并发场景下表现更突出，毕竟锁的粒度小。
- 当表的大部分数据需要被修改，或者是多表复杂关联查询时，建议使用表锁优于行锁。
- 为了保证数据的一致完整性，任何一个数据库都存在锁定机制。锁定机制的优劣直接影响到一个数据库的并发处理能力和性能。

## mysql事务日志
- Bin Log:是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的
- Redo Log:记录了数据操作在物理层面的修改，mysql中使用了大量缓存，修改操作时会直接修改内存，而不是立刻修改磁盘，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。
- Undo Log: 除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC

# MVCC 原理
多版并发本控制: 指的是一种提高并发的技术。只有写写之间相互阻塞，其他操作都可以并行，这样大幅度提高了InnoDB的并发度。与MVCC相对的，是基于锁的并发控制。
**解决了什么问题：**
- 高并发下的RC与RR的事务隔离，主要解决读-写的冲突，可以保证不阻塞的读到一致的数据。适用于读多写少的场景
- 额外的还有乐观并发控制（OCC），主要解决写-写的冲突，认为事务间争用没有那么多，所以先进行修改，在提交事务前，检查一下事务开始后，有没有新提交改变，如果没有就提交，如果有就放弃并重试。乐观并发控制类似自选锁。乐观并发控制适用于低数据争用，写冲突比较少的环境。
- 多版本并发控制可以结合基于锁的并发控制来解决写-写冲突，即MVCC+2PL，也可以结合乐观并发控制来解决写-写冲突。

**MVCC特点：**
- MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作
- 其他两个隔离级别够和MVCC不兼容, 因为 READ UNCOMMITTED 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。
- MVCC的实现方式有多种, 典型的有乐观(optimistic)并发控制 和 悲观(pessimistic)并发控制。

**RC与RR在MVCC中的区别：**
- rr是在事务开始时读数据。事务提交后读不到新的。
- rc是语句执行前读数据生成readview。所以能读到其他事务已提交的数据。
## read view
InnoDB支持MVCC多版本，其中RC（Read Committed）和RR（Repeatable Read）隔离级别是利用consistent read view（一致读视图）方式支持的。 所谓consistent read view就是在某一时刻给事务系统trx_sys打snapshot（快照），把当时trx_sys状态（包括活跃读写事务数组）记下来，之后的所有读操作根据其事务ID（即trx_id）与snapshot中的trx_sys的状态作比较，以此判断read view对于事务的可见性。
Read view中保存的trx_sys状态主要包括

low_limit_id：high water mark，大于等于view->low_limit_id的事务对于view都是不可见的
up_limit_id：low water mark，小于view->up_limit_id的事务对于view一定是可见的
low_limit_no：trx_no小于view->low_limit_no的undo log对于view是可以purge的
rw_trx_ids：读写事务数组
RR隔离级别（除了Gap锁之外）和RC隔离级别的差别是创建snapshot时机不同。 RR隔离级别是在事务开始时刻，确切地说是第一个读操作创建read view的；RC隔离级别是在语句开始时刻创建read view的。

创建/关闭read view需要持有trx_sys->mutex，会降低系统性能，5.7版本对此进行优化，在事务提交时session会cache只读事务的read view。
详情参考：[!mvcc readview原理-淘宝](http://mysql.taobao.org/monthly/2018/03/01/)
