## 前言
MySQL Innodb为什么用B+树做索引？ 为什么连数据都是以B+树形式存储的？ 聚簇索引与辅助索引的关系是什么样的？ 它和B树的区别又是什么，它们的性能差异和各自擅长的场景又是什么？
数据库索引是怎样执行的？请耐心阅读本文，本文将对MySQL 中的B+树进行详细的解释.


### mysql索引原则
- 表是基于聚簇索引的，如果未指定主键则Innodb会选择一列最先创建的唯一索引。还没有的话就创建一个隐藏的rowId列作为聚簇索引。
- 查找过程不是直接定位到记录行，而是先找到对应的页读到内存中再进行搜索。
- 辅助索引（普通索引）中，叶子节点里会存放字段值和对应数据的rowid，如果查询了辅助索引以外的字段则会根据rowid回溯到主键索引中查询数据。
- 聚簇索引中的数据并不是连续的，事实上是逻辑连续，真正存放的是数据的磁盘位置。可以直接定位到具体的数据。

### B+树的数据结构
- 它本质上是一个平衡多路查找树，二叉平衡查找树类似，也是通过二分查找来搜索数据。
- 排序方式：节点排序方式是从小到大，从左向右的顺序进行存储。
- 子节点数量控制：非叶节点的子节点数>1，且<=M ，且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）
- 关键字数量控制：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);
- 所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null(即没有指向物理数据)
- 叶子结点存储的并不是数据本身，而是数据所处的物理磁盘地址。

**B+树的数据结构**
![B+树](/images/post-mysql-indexbtree/B+树图.png)
**B+树的数据存放图示**
![B+树索引数据存放](/images/post-mysql-indexbtree/索引数据存放示例.png)
**B+树回表图示**
![B+树普通索引回表](/images/post-mysql-indexbtree/B+树辅助索引回表过程.jpg)

### B+树与B树的区别
- B树数据存放在整棵树上，B+树的数据仅存在于叶子结点上。
- B树需要把找到的节点及所有子节点全部读取到内存然后搜索，而B+树直接定位到叶子节点，把满足条件的叶子（在数据库中也叫页）读到内存搜索。理想情况下理论性能要高于B树。


### 如何保持数据均匀的
**插入过程**
![插入连续数据](/images/post-mysql-indexbtree/b+树插入连续数据.gif)
插入连续数据
![插入非连续数据](/images/post-mysql-indexbtree/B+树插入非连续数据.gif)
树插入非连续数据

### B+树的curd操作
因为已经有人写的挺好了，我就不重复造轮子了[点击这里查看](https://www.cnblogs.com/nullzx/p/8729425.html)

### MySQL Innodb为什么使用B+树作为索引
一样有人写的很好了[点击这里查看](http://kongchen.github.io/why-b-tree/)

## 堆组织表HOT
- 其索引中记录了记录所在位置的rowid，查找的时候先找索引，然后再根据索引rowid找到块中的行数据
- 索引和数据是分离的
- 数据是散放的，索引和表的数据是分离的，参考Mysql MyIsam存储引擎
- 堆组织表不需要排序，所以存储速度快但是查找的时候需要全表扫描。于是出现了索引，通过少量字段的索引来直接定位数据位置。如果堆是有序的，那么同理也会加速数据的查找速度，然后索引组织表就出现了。
- 适用于数据存储与归档
## 索引组织表IOT
- 其行数据以索引形式存放，因此找到索引，就等于找到了行数据。
- 索引和数据是放在一起的
- 以B+树为存储结构
- 适用于读多写少的场景
