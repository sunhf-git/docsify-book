# 2021年度JVM源码面试题

## JVM指令

### 数据交换指令
- jvm的数据交换指令都有哪些？
```
iload、istore、lload、lstore、fload、fstore、dload、dstore、ldc、bipush、baload、bastore、caload、castore
```
- 操作数栈的作用
```
JVM没有物理寄存器，所以用操作数栈和PC寄存器来替代。注意，这里又提到了操作数
栈哦，重要的事说三遍，何况这么重要的概念!后面会反反复复提到这个概念哟。JVM保存现
场和恢复现场的解决方案是向Java堆栈中压人一个栈帧，函数返回的时候从Java 堆栈中弹出
一个栈帧。
JVM .调用函数的时候，不能像CPU硬件那样，直接跳转就能找到对应的代码段。这是因
为Java函数的代码并没有被存放到代码段中，而是被放在了一个code缓存中，每-一个Java函
数的代码块在这个code缓存中都会有一个索引位置，最终JVM会跳转到这个索引位置处执行
Java函数调用。同时，Java 的函数一定是被封装在类中的，因此JVM在执行函数调用时，还需
要通过类寻址等等- - 系列运算，最终才能定位这个人口。
```
### 方法调用指令
- 调用字节码相关的指令都有哪些
```
1：invokestatic，用于调用静态方法 
2：invokespecial，用于调用私有实例方法，构造器，以及实用 super 关键字调用父类的实例方法或构造器，以及所实现接口的默认方法。 
3：invokevirtual，用于调用非私有实例方法。 
4：invokeinterface，用于调用接口方法。 
5：invokedynamic，用于调用动态方法。
```
### 运算指令集
```
JVM和运算相关的指令集主要有算术运算、位运算、比较运算、逻辑运算等，JVM还为
各种基本类型的运算提供不同的操作码; x86 也有算术运算、逻辑运算、位运算、比较运算，
但是所有的操作都是直接针对寄存器中的二进制数进行的，不区分数据类型。
JVM规范中常见的运算指令包括iadd(对两个int型数据求和)、isub(对两个int型数据做
减法)、fadd(对两个float浮点数进行求和)、ddiv(两个double双精度型数据相除)等。
```
### 控制转移指令
```
与硬件CPU一样,JVM规范也提供了常见的控制转移指令,例如switch分支选择指令、if..
else条件判断、do..while循环、for 循环、foreach循环、returm 返回、break 中断循环、continue
继续循环。不多讲，大家都懂的。
```
### 对象创建与类型转换指令
```
作为一门]面向对象的语言，JVM规范自然要提供一套创建对 象的指令。在Java语法层面使
用关键字new可以实例化-一个对象，而对应的字节码指令也是
JVM规范还提供了“窄化类型转换”指令，与“窄化类型转换”指令相对的是“宽化类型
转换”指令，只不过后者是JVM内部天生支持的，不需要另外使用指令。
除了以上这些指令, JVM规范还提供了很多其他物理CPU所没有的指令，例如，抛出异
常的指令，用于线程同步的指令，等等。
```

## 函数调用机制

### 重载和重写的区别是什么

```
重载：同一个类中定义名字相同的方法，但是参数类型或者参数个数必须不同。

重载的方法在编译过程中就可完成识别。具体到每一个方法的调用，Java 编译器会根据所传入参数的生命类型来选取重载方法。选取的过程分以下三个阶段： 
1：在不考虑对基本类型自动装拆箱，以及可变长参数的情况下选取重载方法。 
2：如果第 1 个阶段未找到，那么在允许自动装拆箱，但是不允许可变长参数的情况下选出重载方法。 
3：如果第 2 个阶段未找到，那么在允许自动装拆箱以及允许可变长参数的情况下选出重载方法。

如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。

重写：子类定义了跟父类方法同名，参数类型一致的方法，就叫做子类重写了父类方法。

Java 是一门面向对象的变成语言，它的一个重要的特性就是多态。而方法的重写，正是多态最重要的一种体现方式。
```
- 分析以下代码确定运行结果
```java
public class OverrideParent {

  public void hello(Integer b) {
    System.out.println("我是parent hello");
  }
}

public class OverrideChild extends OverrideParent {

  public void hello(Integer b) {
    System.out.println("我是 Integer child hello");
  }

  public void hello(int b) {
    System.out.println("我是 int child hello");
  }

  public static void main(String[] args) {
    OverrideChild p = new OverrideChild();
    p.hello(new Integer(1)); //输出 我是 Integer child hello
    p.hello(1); //输出 我是 int child hello

    OverrideParent p1 = new OverrideChild(); 
    p1.hello(1); //注释hello(Integer b)的重写方法时输出 我是parent hello, 否则输出 我是 int child hello

  }

}
```

### 静态绑定和动态绑定
- java中的重写和重载分别属于哪种绑定类型
 ```
 Java 虚拟机判定重写的依据是：方法名，参数类型以及返回类型都相同。由于重载方法的区分在编译阶段已经完成，我们可以认为 Java 虚拟机不存在重载这一概念。因此，重载也被称为静态绑定，或者叫编译时多态。而重写则被称为动态绑定。
 Java 虚拟机中的静态绑定指的是解析时便能够直接识别目标方法的情况，动态绑定指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。
 ```
### 栈帧结构
```
为了能高效地管理程序方法调用，有条不紊地进行嵌套的方法调用和方法返回，JVM维护了一个栈结构，称为虚拟机方法栈（这里没考虑Native方法）。栈里面存放的一个个实体称为栈帧，每一个栈帧都包括了局部变量表，操作数栈，动态连接，方法返回地址和一些额外的附加信息。在编译时，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中。
```

#### 局部变量表
```
局部变量表用于存放方法参数和方法内部定义的局部变量。局部变量表的容量以Slot为最小单位，一个Slot可以存放一个32位以内的数据类型，long和double需要两个Slot存放。
如果执行的方法是非static方法，那局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用（this）。
为了节省栈帧空间，局部变量表中的Slot是可以重用的。如果一个局部变量定义了但没有赋初值是不能使用的。
```

#### 操作数栈
```
JVM解析执行字节码是基于栈结构的。比如做算术运算时是通过操作数栈来进行的，在调用其他方法时是通过操作数栈来进行参数的传递。
```

#### 方法调用大致过程
```
除非被调用的方法是类方法，每一次方法调用指令之前，JVM先会把方法被调用的对象引用压入操作数栈中，除了对象的引用之外，JVM还会把方法的参数依次压入操作数栈。
在执行方法调用指令时，JVM会将函数参数和对象引用依次从操作数栈弹出，并新建一个栈帧，把对象引用和函数参数分别放入新栈帧的局部变量表slot0，1，2…。
JVM把新栈帧push入虚拟机方法栈，并把PC指向函数的第一条待执行的指令。
```

#### 方法调用的字节码指令
JVM里面提供了4条方法调用字节码指令。分别如下：
invokestatic:调用静态方法
invokespecial:调用实例构造器<init>方法、私有方法和父类方法（super(),super.method()）
invokevirtual:调用所有的虚方法(静态方法、私有方法、实例构造器、父类方法、final方法都是非虚方法)
invokeinterface:调用接口方法，会在运行时期再确定一个实现此接口的对象
invokestatic和invokespecial指令调用的方法都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，它们在类加载阶段就会把符号引用解析为该方法的直接引用。直接引用就是一个指针或偏移量，可以让JVM快速定位到具体要调用的方法。

invokevirtual和invokeinterface指令调用的方法是在运行时确定具体的方法地址，接口方法和实例对象公有方法可以用这两个指令来调用。

#### invokevirtual和invokeinterface的区别
从上面我们可以发现，虚函数表上的虚方法是按照从父类到子类的顺序排序的，因此对于使用invokevirtual调用的虚函数，JVM完全可以在编译期就确定了虚函数在方法表上的offset，或者在首次调用之后就把这个offset缓存起来，这样就可以快速地从方法表中定位所要调用的方法地址。

然而对于接口类型引用，由于一个接口可以被不同的Class来实现，所以接口方法在不同类的方法表的offset当然就（很可能）不一样了。因此，每次接口方法的调用，JVM都会搜寻一遍虚函数表，效率会比invokevirtual要低。


#### 动态分派
当JVM遇到invokevirtual或invokeinterface时，需要运行时根据方法的符号引用查找到方法地址。具体过程如下：

在方法调用指令之前，需要将对象的引用压入操作数栈
在执行方法调用时，找到操作数栈顶的第一个元素所指向的对象实际类型，记作C
在类型C中找到与常量池中的描述符和方法名称都相符的方法，并校验访问权限。如果找到该方法并通过校验，则返回这个方法的引用；
否则，按照继承关系往上查找方法并校验访问权限；
如果始终没找到方法，则抛出java.lang.AbstractMethodError异常；
可以看到，JVM是通过继承关系从子类往上查找的对应的方法的，为了提高动态分派时方法查找的效率，JVM为每个类都维护一个虚函数表。
#### 虚函数表
JVM实现动态绑定的原理类似于C++的虚函数表机制，但C++的虚函数表是实现多态中必不可少的数据结构，但JVM里引入虚函数表的目的是加快虚方法的索引。

JVM 会在链接类的过程中，给类分配相应的方法表内存空间。每个类对应一个方法表。这些都是存在于方法区中的。这里与 C++略有不同，C++中每个对象的第一个指针就是指向了相应的虚函数表。而 Java 中每个对象的对象头有一个类型指针，可以索引到对应的类，在对应的类数据中对应一个方法表。也就是C++的方法表是对象级别的，而Java的方法表是类级别的。

一个类的方法表包含类的所有方法入口地址，从父类继承的方法放在前面，接下来是接口方法和自定义的方法。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同的方法的入口地址一致。如果子类重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。


## 常量池

## JIT机制