# java类解析机制

![java类解析机制](/images/code-1.jpg)

# 前言

**解析阶段底层是怎样实现的**
- 类加载机制与类加载器之间是什么样的关系
    - 接口
    - 实现类
- 如果你的字节码文件有错，是加载时就报错，还是运行时
- 书上说的比如像准备阶段、解析阶段、在hostspot源码中真的有吗
- 如果实现一个类加载器，不按照类加载机制实现可不可以

- 以访问类的静态属性为例
    - 什么时机、解析什么
        - 类、接口、属性、方法
    - 如何避免多次解析
        - 常量池缓存(key是什么、value是什么)
    - 加载阶段、链接阶段、初始化阶段都不是一气呵成的
    - 解析阶段一般都是与初始化阶段同时进行的
- 类加载器
    - 根类加载器长什么样子
    - 父子关系是如何建立的
    - 这个类是何时被加载的：sun_launcher_LauncherHelper
- 类加载器加载的类是如何存储的
- 类加载器实现应用隔离
- 如何查看一个类的类加载器
- 获取一个类的class对象有哪些方式
- 元空间的缺陷
    - 碎片化问题
- 双亲委派
- 打破双亲委派
    - spi
    - 自定义类加载器
- 沙箱安全
- 反射的底层原理

# 类加载器是如何存储的

面试题：元空间的弊端是什么（碎片化），怎么产生的


# 类的加载过程
![类加载流程](/images/java17/类加载流程.png)
- 通过类的全限定名获取class文件
- 解析成运行时数据，及instanceKlass实例，存放在方法区
- 在堆区生成该类class对象，即instanceMirrorKlass实例
- 预加载：包装类、如：String Thread等
- 因为没有指明必须从哪获取class文件，所以支持各种各样的方法
    - 从压缩包中读取，如：jar war
    - 从网络中获取 如：web applet
    - 动态生成， 如：动态代理、CGLIB
    - 由其他文件生成，如：jsp

[类的加载过程](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.md)

## 验证
- 运行前检查
    - 文件格式验证
    - 元数据验证
    - 字节码验证
    - 符号引用验证

## 准备
- 面试题：为什么要有准备阶段，静态变量其实已经直接赋值了 为什么还要赋初值。
    - 经过加载阶段后生成了class对象,class对象生成后里面是没有值的，需要准备阶段来初始化值。准备阶段会把赋值和初始化的过程都完成。
    - 如private static int c; //这种情况在class文件中是没有赋值语句的，所以会出现找不到变量的问题，导致程序无法运行
- 实例变量是在创建对象的时候完成赋值的，没有赋值一说。只有静态变量有这一说
- 如果被final修饰，在编译的时候会给属性添加ConstantValue属性，在准备阶段时直接完成赋值，即没有赋初值这一步

## 解析

- 解析阶段的作用是将符号引用改为直接引用
- 符号引用
    - 静态常量池的索引
    
![符号引用说明](/images/java17/符号引用说明.png)
- 直接引用
    - 内存地址

# 其他资料

- [点击观看完整视频](https://www.bilibili.com/video/BV1PV411J7B1?p=3)